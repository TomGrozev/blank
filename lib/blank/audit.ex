defmodule Blank.Audit do
  @pubsub_topic "audit:logs"

  @moduledoc """
  Audit logging management

  Blank supports audit logs on all built-in functionality. You can also use
  functions in this module to log your own custom events. 

  This is used from within Blank but it can also be used in your app by using
  the functions `log!/3` and `multi/4` in this module.

  When an audit log is created using the `log!/3` or the `multi/4` functions, a
  pubsub event is also emitted (`#{@pubsub_topic}`) which is used by the log
  viewing pages to automatically stream new logs.
  """

  import Ecto.Query

  alias Blank.Audit.AuditLog

  @doc """
  Lists all audit logs

  By default, it only returns the 50 most recent logs but that can be changed in
  the supplied options.

  ## Options

  Accepts the following options to help query the logs:

    * `:where` - any where clauses to narrow down the query
    * `:limit` - the maximum number of logs to return (defaults to 50)

  """
  @doc group: "Query"
  @spec list_all(opts :: Keyword.t()) :: [AuditLog.t()]
  def list_all(opts \\ []) do
    user_schema = Application.get_env(:blank, :user_module, Blank.Accounts.Admin)
    struct = struct(user_schema)
    identity_field = Blank.Schema.identity_field(struct)

    fields =
      [identity_field]
      |> Stream.uniq()
      |> Enum.map(&{&1, Blank.Schema.get_field(struct, &1)})

    repo().all(
      from(a in AuditLog,
        where: ^Keyword.get(opts, :where, []),
        order_by: [desc: :inserted_at],
        preload: [:admin, [user: ^Blank.Context.list_query(user_schema, fields)]],
        limit: ^Keyword.get(opts, :limit, 50)
      )
    )
  end

  @doc """
  Lists all audit logs for a supplied user

  Similarlly to `list_all/1`, this defaults to 50 logs returned and available
  options are the same as in that function.
  """
  @doc group: "Query"
  @spec list_all_for_user(
          user_or_id :: %{id: String.t() | integer()} | String.t() | integer(),
          opts :: Keyword.t()
        ) :: [AuditLog.t()]
  def list_all_for_user(user_or_id, opts \\ [])
  def list_all_for_user(%{id: id}, opts), do: list_all_for_user(id, opts)

  def list_all_for_user(id, opts) when is_binary(id) or is_integer(id) do
    user_schema = Application.get_env(:blank, :user_module, Blank.Accounts.Admin)
    struct = struct(user_schema)
    identity_field = Blank.Schema.identity_field(struct)

    fields =
      [identity_field]
      |> Stream.uniq()
      |> Enum.map(&{&1, Blank.Schema.get_field(struct, &1)})

    repo().all(
      from(a in AuditLog,
        join: u in assoc(a, :user),
        where: u.id == ^id,
        where: ^Keyword.get(opts, :where, []),
        order_by: [desc: :inserted_at],
        preload: [:admin, [user: ^Blank.Context.list_query(user_schema, fields)]],
        limit: ^Keyword.get(opts, :limit, 50)
      )
    )
  end

  @doc """
  Lists audit logs generated by the system

  The `clauses` argument accepts any specific where clauses to narrow down the
  logs.
  """
  @doc group: "Query"
  @spec list_all_from_system(any()) :: [AuditLog.t()]
  def list_all_from_system(clauses \\ []) do
    repo().all(
      from(a in AuditLog,
        where:
          is_nil(a.admin_id) and is_nil(a.user_id) and
            a.user_agent ==
              "SYSTEM",
        where: ^clauses,
        order_by: [desc: :inserted_at],
        preload: [:admin, :user]
      )
    )
  end

  @doc """
  Delete all audit logs

  For security reasons, this will create a log after that says who deleted all
  the logs.

  ## Parameters

    * `audit_context` - this is passed from the user's session and contains
      details of the user
  """
  @doc group: "Management"
  @spec delete_all(AuditLog.t()) :: :ok | {:error, any()}
  def delete_all(audit_context) do
    Ecto.Multi.new()
    |> Ecto.Multi.delete_all(:delete_all, AuditLog)
    |> multi(audit_context, "audit_logs.delete_all", %{})
    |> repo().transaction()
    |> case do
      {:ok, _} -> :ok
      error -> error
    end
  end

  @doc """
  Create an audit log

  ## Parameters

    * `audit_context` - this is passed from the user's session and contains
      details of the user
    * `action` - the action that this log is reporting (see below for more
      info)
    * `params` - the additional information to be stored in the log, for blank
      events this is validatied against the action

  ## Actions

  There are some built-in actions (referr to `AuditLog` for more info) but you
  can also add your own, custom actions. Custom actions should be prefixed with
  `app.`, for example you could do `app.send_email` for an send email action.
  """
  @doc group: "Create"
  @spec log!(AuditLog.t(), String.t(), map()) :: AuditLog.t()
  def log!(audit_context, action, params)
      when is_binary(action) and
             is_map(params) do
    AuditLog.build!(audit_context, action, params)
    |> repo().insert!()
    |> tap(&push_pubsub(&1))
  end

  @doc """
  Create an audit log as part of a multi operation

  This operates the same as `log!/3` the first argument is an `Ecto.Multi`.
  However, the fourth parameter can either be a map of parameters (such as in
  the `log!/3` function) or a two argument function. The first argument of the
  function is the `aduit_context` and the second is the multi state, which will
  allow you to get info of the actions on an item before this function.

  ## Example

  The following shows how to use this function when using the parameters from a
  function.

      Ecto.Multi.new()
      |> Ecto.Multi.insert(:item, changeset)
      |> Audit.multi(audit_context, "some_action", fn audit_context, %{item: item} ->
        %{audit_context | params: %{item_id: item.id}}
      end)
      |> MyRepo.transaction()

  """
  @doc group: "Create"
  @spec multi(Ecto.Multi.t(), AuditLog.t(), String.t(), fun() | map()) ::
          Ecto.Multi.t()
  def multi(multi, audit_context, action, fun) when is_function(fun, 2) do
    Ecto.Multi.run(multi, :audit, fn repo, results ->
      audit_log = AuditLog.build!(fun.(audit_context, results), action, %{})

      {:ok, repo.insert!(audit_log)}
      |> tap(fn {:ok, log} ->
        push_pubsub(log)
      end)
    end)
  end

  def multi(multi, audit_context, action, params) do
    multi
    |> Ecto.Multi.insert(:audit, fn _ ->
      AuditLog.build!(audit_context, action, params)
    end)
    |> Ecto.Multi.run(:broadcast, fn _repo, %{audit: log} -> push_pubsub(log) end)
  end

  defp repo, do: Application.fetch_env!(:blank, :repo)

  defp push_pubsub(log) do
    Phoenix.PubSub.broadcast(Blank.PubSub, @pubsub_topic, {:audit_log, log})
  end
end
